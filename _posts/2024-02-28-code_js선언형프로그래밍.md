---
layout: single
title: Javascript 선언형프로그래밍 
categories: code
tag: [함수형, FP, 패러다임, Javascript]
toc: true
#author_profile: false
#sidebar:
#    nav: "docs"
---

어느순간부터 선언적이지 않은 코드는 잘못되었다는 분위기가 팽배해졌다. 명령형은 틀리고 선언형 프로그래밍이 맞다라는 말은 개인적으로 동의할 수 없으나 이 얘기는 나중에 써보기로 하고  
오늘은 우리가 작성하는 선언형 프로그래밍에 대해 개인적인 의견을 써볼려고 한다.

부제는 "Javascript 선언형 프로그래밍 정말 선언적이고 유지보수성 괜찮은가요?" 이다. 

Javascript는 ES6부터 람다 표현식을 쓸수 있으면서 이를 도와주는 여러 도구들이 추가되었는데 대표적으로 map, filter, reduce 등이다.  
아래 간단한 예제를 보자.

```javascript
// map().filter().reduce()가 한번에 사용되는 예제
const numbers = Array.from({ length: 10 }, (_, index) => index + 1); // 1부터 10까지의 배열 생성

const add = (acc, curr) => acc + curr;

const result = numbers
  .map(num => num + 10) // 각 요소에 10을 더하기
  .filter(num => num % 2 === 0) // 2의 배수인 요소만 필터링
  .reduce(add, 0); // 요소들을 합산

console.log(result); // 결과 출력
```

## 정말 선언적인가?

선언적이란 말에 매몰되어 있는지 모르겠지만 객체 뒤에 배열 메소드를 붙여 사용하는게 선언적이라는 느낌이 들지 않았다. 
행동의 목적이 우선시 되고 그다음 속성값이 나오는게 훨씬더 선언적이라고 생각했다.
> [1,2,3].map(a=>a+1);  // 1,2,3을 map을 만드는데 1을 더해라
> map(a=>a+1, [1,2,3]); // map을 뱉어낼건데 1을 더해서 줄거야. 대상은 [1,2,3] 이야

위 예제를 보았을때 선언적이고 목적지향적인건 전자보다 후자가 훨씬더 가깝다고 생각한다. 이러한 개념ß이 없을까 찾아보던중 lisp이라는 '함수형언어' 발견했다.  
> (+ 1 2) // lisp은 더할때도 이렇게 한다.

다음 포스트에선 조금더 선언적으로 코드를 짜는 법에 대해 알아보자.




[//]: # (람다식으로 구성되어 있고 함수로 분리 하지 않았지만 javascript 내장 함수를 사용하여 선언적으로 구성한 코드이다.  )

[//]: # (이러한 코드 구성이 이제는 흔해졌고 **'순수함수'**로 분리->작성 한다면 깔끔해지겠지만 아무리 생각 해도 마음에 들지 않았다.)
[//]: # (유지보수성이 좋으려면 여러가지가 중요하겠지만 필자는 잘 읽히는게 가장 중요하다고 생각한다. 사람은 일반적으로 절차적으로 생각한다. )

[//]: # (코드를 보면 당연히 위에서 부터 보기 시작한다. 문제는 선언적이라고 되어 있는 코드의 서순부터 시작된다. )

[//]: # (위에서부터 순차적으로 내려오다 선언적인 코드를 만나면 이해하기 위해 뒤에서 부터 읽어야 한다.  )

[//]: # ()
[//]: # (<img src="/images/code/img.png" alt="">  )

[//]: # (위 예제는 중첩이 적어 다행이지만 map&#40;&#41;.filter&#40;&#41;.reduce&#40;&#41;이 중첩되서 사용된다고 생각해보자. 목적은 reduce인게 맞지만  )

[//]: # (함수로 분리하면 문단자체는 읽기 쉬워지나 함수로 들어가서 보게 되면 결국엔 다시 시선의 방향이 뒤집혀야 한다.  )

[//]: # (개인적으론 한글책을 읽고 있는데 중간중간 영어지문이 섞여 있는 책을 읽는 느낌이었다.)